# CSQAQ API 限流说明

## API限流规则

根据CSQAQ API的限流规则，不同类型的IP有不同的请求频率限制：

### 1. 绑定IP端口
- **限制**: 30秒/次
- **说明**: 如果您使用的是绑定到特定端口的IP地址
- **使用方法**: `./bulk_fetch_goods_optimized -binding`

### 2. 普通IP
- **限制**: 1秒/次  
- **说明**: 普通的公网IP地址
- **使用方法**: `./bulk_fetch_goods_optimized` (默认模式)

## 脚本优化

### 原始脚本问题
原始脚本使用了并发处理和较短的请求间隔（3秒），这可能导致：
- 触发API限流（429错误）
- IP被临时或永久封禁
- 数据获取失败

### 优化后的改进

#### 1. 智能限流控制
```go
// 根据IP类型自动调整请求间隔
if ac.config.IsBindingIP {
    interval = ac.config.BindingInterval  // 30秒
} else {
    interval = ac.config.NormalInterval   // 1秒
}
```

#### 2. 精确的时间控制
```go
// 精确控制请求间隔，避免超出限制
elapsed := time.Since(ac.lastRequest)
if elapsed < interval {
    waitTime := interval - elapsed
    time.Sleep(waitTime)
}
```

#### 3. 移除并发处理
- 原始脚本使用3个并发goroutine
- 优化后改为串行处理，严格遵守API限制

## 使用建议

### 1. 确定您的IP类型
在使用脚本之前，请确认您的IP类型：

```bash
# 如果您使用绑定IP端口
./bulk_fetch_goods_optimized -binding

# 如果您使用普通IP（默认）
./bulk_fetch_goods_optimized
```

### 2. 监控API响应
程序会自动显示限流等待信息：
```
API限流等待 29.5s (good_id 12345)
```

### 3. 错误处理
如果仍然收到429错误，说明：
- 可能选择了错误的IP模式
- API限制可能更加严格
- 建议增加请求间隔

## 性能影响

### 绑定IP模式
- **优点**: 可能有更高的稳定性
- **缺点**: 处理速度很慢（30秒/次）
- **适用场景**: 长期稳定的数据收集

**预估时间**: 
- 12021-24041 (12021个商品)
- 12021 × 30秒 = 360,630秒 ≈ 100小时

### 普通IP模式  
- **优点**: 相对较快的处理速度
- **缺点**: 可能不如绑定IP稳定
- **适用场景**: 日常数据收集

**预估时间**:
- 12021-24041 (12021个商品)  
- 12021 × 1秒 = 12,021秒 ≈ 3.3小时

## 最佳实践

### 1. 分批处理
对于大量数据，建议分批处理：
```bash
# 修改配置中的RangeStart和RangeEnd
# 例如：先处理12021-15000，再处理15001-18000等
```

### 2. 监控和日志
- 定期检查程序日志
- 监控429错误的频率
- 如果错误频繁，考虑增加间隔时间

### 3. 网络稳定性
- 确保网络连接稳定
- 考虑在网络条件好的时间段运行
- 使用稳定的服务器环境

## 故障排查

### 常见问题

#### 1. 频繁的429错误
**原因**: 请求过于频繁
**解决**: 
- 检查是否选择了正确的IP模式
- 考虑增加请求间隔

#### 2. 连接超时
**原因**: 网络不稳定或API服务器负载高
**解决**:
- 检查网络连接
- 增加API超时时间
- 在网络条件好的时候运行

#### 3. IP被封禁
**原因**: 违反了API限流规则
**解决**:
- 等待封禁解除（通常几小时到24小时）
- 严格遵守API限制
- 考虑更换IP

## 代码示例

### 自定义配置
```go
config := &Config{
    IsBindingIP:     true,                 // 使用绑定IP模式
    BindingInterval: 35 * time.Second,     // 增加到35秒以确保安全
    NormalInterval:  1200 * time.Millisecond, // 普通IP使用1.2秒间隔
}
```

### 监控API调用
```go
log.Printf("API限流等待 %v (good_id %d)", waitTime, id)
```

这样的优化确保了脚本能够长期稳定运行，避免触发API限制。
